{% extends "base.html" %}


{% block title %}Renkoru - CSS{% endblock %}

{% block content %}

<section class="group">

  <aside class="right-sidebar grayed">
    SideBar
  </aside>

  <section class="content">

    <section class="notes">

      <h1>CSS</h1>

      <p>
        Remember that each browser has its css pre styles. And you need to overwrite them
        if you want same styles on all browsers. (it is named as "Reset CSS")
      </p>

      <article>
        <h2> Вычисление специфичности </h2>
        <p>
          Каждый селектор в CSS имеет вес специфичности, он вместе с положением
          в каскаде определяет, как будут отображаться стили.

          В уроке 1 «Создание первой веб-страницы» мы говорили о трёх разных
          видах селекторов: селектор типа, класс и идентификатор. Каждый из этих
          селекторов имеет различный вес специфичности.

          У селектора типа низкий вес специфичности и значение балла 0-0-1. У
          селектора класса средний вес специфичности и значение балла
          0-1-0. Наконец, у идентификаторов высокая специфичность и значение
          балла 1-0-0. Как мы видим, баллы специфичности вычисляются с помощью
          трёх колонок. В первой колонке количество идентификаторов, во второй
          классов, а третья колонка считает селекторы типа.

          Важно отметить, что идентификатор имеет больший вес специфичности чем
          селектор класса, а класс больший вес, чем селектор типа.
        </p>

        <pre>
          <code class="language-css">
        .hotdog p {          /* 0-1-1 */
            /* ... */
        }
        .hotdog p.mustard {  /* 0-2-1 */
            /* ... */
        }
        .hotdog .mustard {   /* 0-2-0 */
            /* ... */
        }
          </code>
        </pre>
      </article>

      <article>
        <h2>Sizes</h2>
        <p>Pixels</p>
        <p>'%' is size in percents of parent size</p>
        <p>
          1em = font-size <br/>
          em часто применяется для стилизации текста, в том числе размера
          шрифта, а также пространства вокруг текста, включая margin и
          padding.
        </p>
      </article>

      <article>
        <h2>CSS. display</h2>
        <p>
          Есть немало значений для свойства <span class="style-inline">display</span>, но наиболее
          распространённые это
          <span class="style-inline">block</span>,
          <span class="style-inline">inline</span>,
          <span class="style-inline">inline-block</span> и
          <span class="style-inline">none</span>.
          Мы можем изменить значение свойства
          <span class="style-inline">display</span>
          элемента, выбрав этот элемент в CSS и задав новое значение свойства
          <span class="style-inline">display</span>.
          Значение
          <span class="style-inline">block</span>
          сделает этот элемент блочным.  Значение
          <span class="style-inline">inline</span>
          сделает
          этот элемент строчным.  Самое интересное это значение
          <span class="style-inline">inline-block</span>
          . Его использование позволит элементу вести себя как
          блочный, включая все свойства блочной модели (которые мы вскоре
          рассмотрим). Однако, элемент будет отображаться на строке с
          другими элементами, а не будет начинаться с новой строки по
          умолчанию.
          В заключение, используя значение none полностью скрываем элемент и
          отображаем страницу, словно элемента не существует. Любые элементы,
          вложенные в такой элемент, также будут скрыты.
        </p>
      </article>

      <article>
        <h2> Что такое блочная модель? </h2>
        <p>
          В соответствии с концепцией блочной модели,
          каждый элемент на странице представляет собой прямоугольный блок и
          может иметь ширину, высоту, поля, границы и отступы.

          Это стоит повторить: Каждый элемент на странице представляет собой
          прямоугольный блок.
          Каждая часть блочной модели соответствует свойству CSS:
          <span class="style-inline">width</span>,
          <span class="style-inline">height</span>,
          <span class="style-inline">padding</span>,
          <span class="style-inline">border</span> и
          <span class="style-inline">margin</span>.
        </p>
        <p>
          В соответствии с блочной моделью общая ширина элемента может
          быть рассчитана по следующей формуле: <br>

          margin-right + border-right + padding-right + width + padding-left + border-left + margin
        </p>
        <img alt="Box-Model" src="static/box-model.png">
      </article>

      <article>
        <h2>CSS. width</h2>
        <p>
          По умолчанию ширина элемента основана на значении
          <span class="style-inline">display</span>.
          У блочных элементов ширина по умолчанию 100% и занимает всё доступное
          горизонтальное пространство. Строчные и строчно-блочные элементы
          расширяются и сжимаются горизонтально для размещения их
          содержимого. Строчные элементы не могут иметь фиксированный размер,
          таким образом, ширина и высота относятся только к не строчным
          элементам. Чтобы задать определённую ширину для не строчных элементов,
          используйте свойство
          <span class="style-inline">width</span>.
        </p>
        <h5>inline elem: <em>(css width does not work)</em></h5>
        <span class="grayed" style="width: 400px">width = 400px</span>

        <h5>block elem:</h5>
        <div class="grayed" style="width: 400px">width = 400px</div>
      </article>


      <article>
        <h2> Размеры строчно-блочных элементов </h2>
        <p>
          Пожалуйста, помните, что строчные элементы не принимают свойства
          <span class="style-inline">width</span>
          и height и любые их значения. Блочные и строчно-блочные элементы,
          однако, принимают свойства
          <span class="style-inline">width</span> и
          <span class="style-inline">height</span>
          и соответствующие им значения.
        </p>
      </article>

      <article>
        <h2>margin</h2>
        <p>
          Свойство margin позволяет нам установить пространство, которое
          окружает элемент.
          <span class="style-inline">margin</span>
          находятся за пределами любых границ и
          полностью прозрачны в цвете. Они могут использоваться для
          позиционирования элементов в конкретном месте на странице или добавить
          пустое пространство, сохраняя все другие элементы на безопасном
          расстоянии.

          Одной из причуд
          <span class="style-inline">margin</span>
          являются вертикальные значения, сверху и снизу,
          они не применяются к строчным элементам, но применяются к блочным и
          строчно-блочным элементам.
        </p>

        <h5>inline elem: <em>(vertical margin does not work)</em></h5>
        <div class="bordered-wrapper">
          <span class="grayed" style="margin: 10px">margin: 10px</span>
        </div>

        <h5>block elem:</h5>
        <div class="bordered-wrapper">
          <div class="grayed" style="margin: 10px">margin: 10px</div>
        </div>
      </article>


      <article>
        <h2> margin и padding для строчных элементов </h2>
        <p>
          Строчные элементы ведут себя немного по-другому, чем блочные и
          строчно-блочные элементы, когда дело доходит до отступов и полей. Для
          строчных элементов
          <span class="style-inline">margin</span>
          работает только горизонтально — слева и
          справа от элементов.
          <span class="style-inline">padding</span>
          работает на всех четырёх сторонах
          строчных элементов, однако вертикальные поля сверху и снизу могут
          выходить за пределы строки выше и ниже элемента.

          Отступы и поля работают как обычно для блочных и строчно-блочных
          элементов.
        </p>
      </article>

      <article>
        <h2> Цвет отступов и полей </h2>
        <p>
          Свойства
          <span class="style-inline">margin</span> и
          <span class="style-inline">padding</span>
          полностью прозрачны и не принимают
          какие-либо цветовые значения. Но будучи прозрачными они
          показывают цвет фона связанных элементов. Для
          <span class="style-inline">margin</span>
          мы видим цвет фона родительского элемента, а для
          <span class="style-inline">padding</span>
          видим цвет фона элемента, к которому применяется
          <span class="style-inline">padding</span>.
        </p>
      </article>

      <article>
        <h2> Границы для отдельных сторон </h2>
        <p>
          Как и со свойствами
          <span class="style-inline">margin</span> и
          <span class="style-inline">padding</span>
          границы могут быть размещены на одной стороне элемента за раз при желании.
          Это требует новых свойств:
          <span class="style-inline">border-top</span>,
          <span class="style-inline">border-right</span>,
          <span class="style-inline">border-bottom</span> и
          <span class="style-inline">border-left</span>.
          Значения для этих свойств такие же, как и для border: ширина, стиль и цвет.
          При желании можно сделать так, чтобы граница появлялась только внизу
          элемента:

          <pre>
            <code class="language-css">
            div {
                border-bottom: 6px solid #949599;
            }
            </code>
          </pre>


          Кроме того, стилями для
          отдельных сторон можно управлять на ещё более тонком
          уровне. Например, если мы хотим изменить только ширину нижней
          границы, то можем использовать следующий код:

          <pre>
            <code class="language-css">
            div {
                border-bottom-width: 12px;
            }
            </code>

          </pre>
          Такое довольно специфичное свойство
          границы включают в себя ряд разделённых дефисом слов, начинающихся с
          <span class="style-inline">border</span>,
          затем идёт выбранная сторона —
          <span class="style-inline">top</span>,
          <span class="style-inline">right</span>,
          <span class="style-inline">bottom</span> или
          <span class="style-inline">left</span>,
          а затем
          <span class="style-inline">width</span>,
          <span class="style-inline">style</span> или
          <span class="style-inline">color</span>,
          в зависимости от желаемого свойства.
        </p>
      </article>

      <article>
        <h2> Размеры блока </h2>
        <p>
          До сих пор блочная модель была аддитивной. Если вы установили для
          <span class="style-inline">width</span>
          400 пикселей, затем добавили 20 пикселей
          <span class="style-inline">padding</span> и
          <span class="style-inline">border</span> 10
          пикселей на каждой стороне, фактическая полная ширина элемента
          становится 460 пикселей. Помните, мы должны сложить значения свойств
          <span class="style-inline">width</span>,
          <span class="style-inline">padding</span> и
          <span class="style-inline">border</span>
          вместе, чтобы получить реальную полную ширину элемента.

          Блочная модель, однако, может быть изменена, чтобы вычисления
          происходили иначе. <strong>CSS3</strong> ввёл свойство
          <span class="style-inline">box-sizing</span>,
          которое позволяет нам точно менять, как блочная модель работает и как вычисляются
          размеры элемента. Это свойство принимает три основных значения —
          <span class="style-inline">content-box</span>,
          <span class="style-inline">padding-box</span> и
          <span class="style-inline">border-box</span>,
          каждое из которых оказывает несколько разное влияние на вычисление размера блока.
        </p>
      </article>

      <article>
        <h2> Свойства и значения специфичные для браузера </h2>
        <p>
          Что означают все эти дефисы и буквы в свойстве
          <span class="style-inline">box-sizing</span>?

          Когда был представлен CSS3, браузеры постепенно начали
          поддерживать разные свойства и значения, включая свойство
          <span class="style-inline">box-sizing</span>,
          путём добавления вендорных префиксов. Когда части
          спецификации CSS3 будут завершены и выпущены новые версии
          браузеров, эти префиксы станут всё менее и менее актуальными. Со
          временем префиксы вряд ли будут проблемой, однако, они всё ещё
          обеспечивают поддержку некоторых старых браузеров. Мы можем
          работать с ними время от времени и, возможно, даже захотим
          использовать их, если нам нужна поддержка старых браузеров.

          Вендорные префиксы можно увидеть для свойств и значений, всё
          зависит от спецификации CSS. Здесь они показаны для свойства
          <span class="style-inline">box-sizing</span>.
          Разработчики браузеров были свободны в выборе, когда
          использовать префикс, а когда нет. Таким образом, одни свойства
          и значения требуют префиксы для некоторых браузеров, а другие
          нет.

          Ниже, когда свойство или значение требует вендорный префикс, то
          префикс будет использоваться только для представления этого
          свойства или значения (в интересах сохранения нашего кода
          простым и кратким). Не забудьте добавить необходимые префиксы,
          когда вы станете писать реальный код.

          Для справки, наиболее распространённые префиксы изложены здесь:

          <pre>
        Mozilla Firefox                       : -moz-
        Microsoft Internet Explorer           : -ms-
        Webkit (Google Chrome и Apple Safari) : -webkit-
          </pre>
        </p>
      </article>

      <article>
        <h3> content-box </h3>
        <p>
          Значение
          <span class="style-inline">content-box</span>
          является значением по умолчанию, оставляя
          блочную модель в качестве аддитивной. Если мы не используем свойство
          <span class="style-inline">box-sizing</span>,
          то это будет значением по умолчанию для всех элементов.
          Размер элемента начинается со свойств
          <span class="style-inline">width</span> и
          <span class="style-inline">height</span>,
          далее к ним добавляются значения свойств
          <span class="style-inline">padding</span>,
          <span class="style-inline">border</span> или
          <span class="style-inline">margin</span> .
        </p>

        <h3>padding-box</h3>
        <p>
          Значение
          <span class="style-inline">padding-box</span>
          изменяет блочную модель путём включения всех значений свойства
          <span class="style-inline">padding</span>
          внутри
          <span class="style-inline">width</span> и
          <span class="style-inline">height</span>
          элемента. При использовании значения
          <span class="style-inline">padding-box</span>,
          если у элемент
          <span class="style-inline">width</span>
          равно 400 пикселей и
          <span class="style-inline">padding</span>
          20 пикселей вокруг всех сторон, фактическая ширина останется 400 пикселей. При
          увеличении
          <span class="style-inline">padding</span>
          на любое значение, размер содержимого внутри элемента сжимается пропорционально.

          Если мы добавим
          <span class="style-inline">border</span> или
          <span class="style-inline">margin</span>,
          эти значения будут добавлены к свойствам
          <span class="style-inline">width</span> или
          <span class="style-inline">height</span>
          для вычисления полного размера блока. Например, если мы добавим
          <span class="style-inline">border</span>
          10 пикселей и
          <span class="style-inline">padding</span>
          20 пикселей вокруг всех сторон элемента, у которого
          <span class="style-inline">width</span>
          400 пикселей, фактическая полная ширина будет 420 пикселей.
        </p>

        <h3> border-box. Выбор размера блока </h3>
        <p>
          Вообще говоря, лучшее значение
          <span class="style-inline">box-sizing</span>
          для применения — это
          <span class="style-inline">border-box</span>.
          Это значение намного упрощает нам математику. Если мы
          хотим, чтобы весь элемент был 400 пикселей в ширину, он останется 400
          пикселей в ширину, независимо от того, какие значения
          <span class="style-inline">padding</span> или
          <span class="style-inline">border</span>
          мы к нему добавляем.

          Кроме того, мы можем легко смешивать значения длины. Скажем, мы хотим,
          чтобы наш блок занимал 40% в ширину. Добавление
          <span class="style-inline">padding</span>
          20 пикселей и
          <span class="style-inline">border</span>
          10 пикселей для всех сторон элемента не сложно и мы по-прежнему
          можем гарантировать, что фактическая ширина нашего блока останется
          40%, несмотря на использование пикселей в другом месте.

          Единственный недостаток свойства
          <span class="style-inline">box-sizing</span>
          в том, что как часть спецификации CSS3 она не поддерживается во всех браузерах, особенно не
          хватает поддержки в старых версиях. К счастью, это становится всё
          менее и менее актуальным, поскольку выходят новые версии. Скорее
          всего, мы можем безопасно использовать свойство
          <span class="style-inline">box-sizing</span>,
          но если вы заметили какие-то проблемы, стоит посмотреть с каким браузером они связаны.
        </p>

        <img alt="" src="static/box-sizing.png">

      </article>


      <article>
        <h2> Универсальный селектор </h2>
        <p>
          На первом этапе данного упражнения мы представили универсальный
          селектор. В CSS звёздочка (*) это универсальный селектор,
          который выбирает каждый элемент. Вместо перечисления всех
          отдельных элементов мы можем использовать звёздочку для выбора
          всех элементов.
        </p>
      </article>


    </section>

    <section class="notes">
      <h1>Позиционирование содержимого</h1>

      <article>
        <h2>Позиционирование через float</h2>
        <p>
          Один из способов позиционирования
          элементов на странице — через свойство
          <span class="style-inline">float</span>.
          Это свойство довольно универсально и может применяться разными путями.

          По существу, свойство
          <span class="style-inline">float</span>
          берёт элемент, убирает его из обычного
          потока страницы и позиционирует слева или справа от родительского
          элемента. Все остальные элементы на странице будут обтекать такой
          элемент. Например, абзацы будут обтекать изображение, если для
          элемента <span class="tag-inline">&lt;img&gt;</span> установлено свойство
          <span class="style-inline">float</span>.

          Когда свойство
          <span class="style-inline">float</span>
          применяется к нескольким элементам одновременно,
          это даёт возможность создать макет с обтекаемыми элементами
          расположенными рядом или напротив друг друга, как показано в
          многоколоночном макете.

          Свойство
          <span class="style-inline">float</span>
          принимает несколько значений, два самых популярных —
          это
          <span class="style-inline">left</span> и
          <span class="style-inline">right</span>,
          они позволяют элементу располагаться слева или
          справа от своего родителя.

          <pre>
            <code class="language-css">
        img {
            float: left;
        }
            </code>
          </pre>

        </p>

        <p>
          Когда мы устанавливаем элемент обтекаемым, то убираем его из
          обычного потока HTML-документа. Это приводит к тому, что ширина
          этого элемента по умолчанию становится шириной его
          содержимого. Иногда, например, когда мы создаём колонки для
          многократно используемого макета, такое поведение
          нежелательно. Это можно исправить путём добавления свойства
          <span class="style-inline">width</span>
          с фиксированным значением для каждой колонки. Кроме того,
          чтобы обтекаемые элементы не соприкасались друг с другом, в
          результате чего содержимое одного элемента располагается рядом с
          другим, мы можем использовать свойство
          <span class="style-inline">margin</span>,
          чтобы установить пространство между элементами.

          Ниже мы расширяем предыдущий блок кода, добавив
          <span class="style-inline">margin</span> и
          <span class="style-inline">width</span>
          для каждой колонки, чтобы лучше формировать наш желаемый результат.

          <pre>
            <code class="language-css">
        section {
            float: left;
            margin: 0 1.5%;
            width: 63%;
        }
        aside {
            float: right;
            margin: 0 1.5%;
            width: 30%;
        }
            </code>
          </pre>

        </p>

      </article>

      <article>
        <h2> float могут изменить значение display у элемента </h2>
        <p>
          Для обтекаемого элемента также важно понимать, что элемент удаляется
          из обычного потока страницы и что у элемента может измениться значение
          <span class="style-inline">display</span>,
          заданное по умолчанию. Свойство
          <span class="style-inline">float</span>
          опирается на то, что у элемента значение
          <span class="style-inline">display</span>
          задано как
          <span class="style-inline">block</span>
          и может изменить значение
          <span class="style-inline">display</span>
          у элемента по умолчанию, если он ещё не отображается как блочный элемент.

          Например, элемент, у которого
          <span class="style-inline">display</span>
          указан как
          <span class="style-inline">inline</span>,
          такой как строчный
          <span class="tag-inline">&lt;span&gt;</span>,
          игнорирует любые свойства
          <span class="style-inline">height</span> или
          <span class="style-inline">width</span>.
          Однако, если для строчного элемента указать
          <span class="style-inline">float</span>,
          значение
          <span class="style-inline">display</span>
          изменится на
          <span class="style-inline">block</span>
          и тогда элемент уже может принимать свойства
          <span class="style-inline">height</span> или
          <span class="style-inline">width</span>.

          Когда мы применяем
          <span class="style-inline">float</span>
          для элемента, то должны следить за тем, как
          это влияет на значение свойства
          <span class="style-inline">display</span>.
        </p>
      </article>

      <article>
        <h2> Очистка и содержимое float </h2>
        <p>
          Свойство
          <span class="style-inline">float</span>
          было первоначально разработано, чтобы позволить
          содержимому обтекать вокруг изображений. Для изображения может
          быть задано
          <span class="style-inline">float</span>
          и всё содержимое вокруг этого изображения,
          естественно, обтекает вокруг него. Хотя это прекрасно работает
          для картинок, свойство
          <span class="style-inline">float</span>
          на самом деле не было предназначено для использования в макете и с целью
          позиционирования и, таким образом, оно идёт с несколькими ловушками.

          Одной из этих ловушек является то, что иногда надлежащие стили
          не отображаются на элементе, который расположен рядом с
          обтекаемым элементом или является его родителем. Когда элемент
          установлен обтекаемым, то он убирается из обычного потока
          страницы и, как результат, стили элементов вокруг этого
          обтекаемого элемента могут получить негативное влияние.

          Часто значения свойств
          <span class="style-inline">margin</span> и
          <span class="style-inline">padding</span>
          интерпретируются некорректно, заставляя их сливаться с обтекаемым
          элементом. Другие свойства также могут быть затронуты.

          Другая ошибка состоит в том, что иногда нежелательный контент
          начинает обтекать элемент с
          <span class="style-inline">float</span>.
          Удаление элемента из потока документа позволяет всем элементам вокруг обтекаемого элемента
          обходить его и задействовать любое доступное пространство
          вокруг обтекаемого элемента, что часто бывает нежелательно.

          Чтобы предотвратить содержимое от обматывания вокруг обтекаемых
          элементов, нам нужно сделать очистку
          <span class="style-inline">float</span>
          и вернуть страницу в её обычный поток. Мы рассмотрим как очистить
          <span class="style-inline">float</span>,
          а затем взглянем на их содержимое.
        </p>
      </article>

      <article>
        <h2> Очистка float </h2>
        <p>
          Очистка
          <span class="style-inline">float</span>
          происходит с помощью свойства
          <span class="style-inline">clear</span>,
          которое принимает несколько различных значений: наиболее часто
          используемые значения —
          <span class="style-inline">left</span>,
          <span class="style-inline">right</span> и
          <span class="style-inline">both</span>.

          <pre>
            <code class="language-css">
            div {
                clear: left;
            }
            </code>
          </pre>

          Значение
          <span class="style-inline">left</span>
          очищает левые
          <span class="style-inline">float</span>,
          в то время как значение
          <span class="style-inline">right</span>
          очищает правые
          <span class="style-inline">float</span>.
          Значение
          <span class="style-inline">both</span>,
          однако, очистит левые и правые
          <span class="style-inline">float</span>
          и часто является наиболее идеальным вариантом.

          Возвращаясь к нашему предыдущему примеру, если мы используем свойство
          <span class="style-inline">clear</span>
          со значением
          <span class="style-inline">both</span>
          для элемента
          <span class="tag-inline">&lt;footer&gt;</span>,
          то можем очистить
          <span class="style-inline">float</span>.
          Важно, что
          <span class="style-inline">clear</span>
          применяется к элементу, указанному после обтекаемых элементов, а не раньше, чтобы
          вернуть страницу в её обычный поток.

          <pre>
            <code class="language-css">
            footer {
                clear: both;
            }
            </code>
          </pre>

        </p>
      </article>

      <article>
        <h2> Содержимое float </h2>
        <p>
          Вместо очистки
          <span class="style-inline">float</span>,
          ещё одним вариантом является установка содержимого
          <span class="style-inline">float</span>.
          Результат получится почти такой же, однако
          содержимое
          <span class="style-inline">float</span>
          действительно гарантирует, что все наши стили будут отображаться надлежащим образом.

          Чтобы установить содержимое
          <span class="style-inline">float</span>,
          обтекаемые элементы должны находиться внутри родительского элемента, он будет выступать в
          качестве контейнера, оставляя поток документа полностью
          обычным за его пределами. В стилях для этого родительского элемента представлен класс
          <span class="style-inline">group</span>
          , как показано здесь:

          <pre>
            <code class="language-css">
            .group::before,
            .group::after {
                content: "";
                display: table;
            }

            .group::after {
                clear: both;
            }

            .group {
                clear: both;
                *zoom: 1;
            }
            </code>
          </pre>

          Здесь немного что происходит, но, по сути, всё что CSS
          делает — очищает все обтекаемые элементы внутри элемента с
          классом group и возвращает документ в обычный поток.

          Более конкретно, псевдоэлементы
          <span class="style-inline">::before </span>и
          <span class="style-inline">::after</span>,
          как указано в уроке 4, динамически генерируют элементы выше и ниже
          элемента с классом 'group'. Эти элементы не включают в себя
          какой-либо контент и отображаются как табличные элементы,
          подобно элементам блочным. Динамически генерируемый элемент
          после элемента с классом 'group' очищает
          <span class="style-inline">float</span>
          внутри элемента с классом 'group', так же, как и clear ранее. И, наконец, элемент
          с классом 'group' также очищает все
          <span class="style-inline">float</span>,
          которые могут появиться до него на случай, если существует
          <span class="style-inline">float</span>
          со значением
          <span class="style-inline">left</span> или
          <span class="style-inline">right</span>.
          Также сюда включена небольшая хитрость, которая заставляет старые браузеры играть красиво.

          Здесь больше кода, чем единственная команда 'clear: both', но он
          может оказаться весьма полезным.

          Когда для элементов задано
          <span class="style-inline">float</span>
          важно следить за тем, как они влияют на поток страницы и убедитесь, что поток страницы
          сбрасывается путём очистки или через содержимое
          <span class="style-inline">float</span>,
          как надо. В противном случае, отслеживание
          <span class="style-inline">float</span>
          может вызвать немало головной боли, особенно на страницах, содержащих
          несколько строк, в каждой из которых несколько колонок.
        </p>
      </article>

      <article>
        <h2> Позиционирование через inline-block </h2>
        <p>
          В дополнение к использованию
          <span class="style-inline">float</span>,
          ещё один способ, которым мы можем позиционировать контент — это применение свойства
          <span class="style-inline">display</span>
          в сочетании со значением
          <span class="style-inline">inline-block</span>.
          Метод с
          <span class="style-inline">inline-block</span>,
          как мы ещё обсудим, в первую очередь полезен для компоновки страниц или для
          размещения элементов в линию рядом друг с другом.

          Напомним, что значение
          <span class="style-inline">inline-block</span>
          для свойства
          <span class="style-inline">display</span>
          отображает элементы в линию и позволяет им принимать все
          свойства блочной модели, включая
          <span class="style-inline">height</span>,
          <span class="style-inline">width</span>,
          <span class="style-inline">padding</span>,
          <span class="style-inline">border</span> и
          <span class="style-inline">margin</span>.
          Применение
          <span class="style-inline">inline-block</span>
          позволяет нам в
          полной мере воспользоваться блочной моделью, не беспокоясь
          об очистке каких-либо
          <span class="style-inline">float</span>.
        </p>
        <p>
          Помните, поскольку строчно-блочные элементы отображаются на одной
          линии друг за другом, они включают единое пространство между
          ними. Когда размер каждого отдельного пространства добавляется к
          ширине и значению горизонтального
          <span class="style-inline">margin</span>
          всех элементов в строке, общая ширина становится слишком большой,
          выталкивая последний элемент
          <span class="tag-inline">&lt;section&gt;</span>
          на новую строку. Чтобы отобразить все элементы
          <span class="tag-inline">&lt;section&gt;</span>
          на одной строке, следует удалить пустое пространство между каждым
          <span class="tag-inline">&lt;section&gt;</span>.
        </p>
      </article>

      <article>
        <h2> Удаление пространства между строчно-блочными элементами </h2>
        <p>
          Есть несколько методов, как удалить пространство между строчно-блочными элементами и
          некоторые из них более сложные, чем другие. Мы собираемся
          сосредоточиться на двух самых простых методах, каждый из которых
          происходят внутри HTML.

          Первое решение — это поместить каждый новый открывающий тег элемента
          <span class="tag-inline">&lt;section&gt;</span>
          в той же строке, что и закрывающий тег предыдущего элемента
          <span class="tag-inline">&lt;section&gt;</span>.
          Вместо использования новой строки для каждого элемента мы в
          итоге начинаем элементы с той же строки. Наш HTML может выглядеть следующим образом:

          <pre>
            <code class="language-markup">
                &lt;header&gt;...&lt;/header&gt;
                &lt;section&gt;
                    ...
                    &lt;/section&gt;&lt;section&gt;
                    ...
                    &lt;/section&gt;&lt;section&gt;
                    ...
                &lt;/section&gt;
                &lt;footer&gt;...&lt;/footer&gt;
            </code>
          </pre>

          Написание строчно-блочных элементов таким образом гарантирует, что пространства
          между такими элементами в HTML не существует. Следовательно,
          пространство и не появится при отображении страницы.
        </p>

        <p>
          Ещё один метод для удаления пространства между
          строчно-блочными элементами состоит в открытии комментария
          HTML непосредственно после закрывающего тега элемента. Затем
          закройте комментарий непосредственно перед открывающим тегом
          следующего элемента. Это позволяет строчно-блочным элементам
          начинаться и завершаться на отдельных строках в HTML и
          «закомментирует» любое потенциальное пространство между
          элементами. В результате код будет выглядеть следующим
          образом:

          <pre>
            <code class="language-markup">
                &lt;header&gt;...&lt;/header&gt;
                &lt;section&gt;
                    ...
                    &lt;/section&gt;&lt;!--
                    --&gt;&lt;section&gt;
                    ...
                    &lt;/section&gt;&lt;!--
                    --&gt;&lt;section&gt;
                    ...
                &lt;/section&gt;
                &lt;footer&gt;...&lt;/footer&gt;
            </code>
          </pre>

          Ни один из этих вариантов не является совершенным, но они полезны. Я
          склоняюсь в пользу применения комментариев для лучшей организации, но
          какой вариант вы выберете полностью зависит от вас.
        </p>
      </article>

      <article>
        <h2> Уникальное позиционирование элементов </h2>
        <p>
          Рано или поздно каждый пожелает точно позиционировать элемент, но
          <span class="style-inline">float</span>
          или строчно-блочные элементы не позволяют проделать такой
          трюк. Обтекаемые элементы, которые удаляют элемент из потока страницы,
          часто приводят к нежелательным результатам, поскольку окружающие
          элементы обтекают вокруг элемента с
          <span class="style-inline">float</span>.
          Строчно-блочные элементы,
          если только мы не создаём колонки, могут быть довольно неудобны, когда
          дело касается правильного положения. Для подобных ситуаций мы можем
          использовать свойство
          <span class="style-inline">position</span>
          в сочетании со свойствами смещения блока.

          Свойство
          <span class="style-inline">position</span>
          определяет, как элемент позиционируется на странице
          и будет ли он отображаться в обычном потоке документа. Оно применяется
          в сочетании со свойствами смещения блока —
          <span class="style-inline">top</span>,
          <span class="style-inline">right</span>,
          <span class="style-inline">bottom</span> и
          <span class="style-inline">left</span>,
          которые точно определяют, где элемент будет расположен путём
          перемещения элемента в разных направлениях.

          По умолчанию у каждого элемента значение
          <span class="style-inline">position</span>
          установлено как
          <span class="style-inline">static</span>,
          это означает, что элемент существует в обычном потоке
          документа и не принимает какие-либо свойства для его
          смещения. Значение
          <span class="style-inline">static</span>
          наиболее часто переписывается значением
          <span class="style-inline">relative</span> или
          <span class="style-inline">absolute</span>,
          которые мы рассмотрим дальше.
        </p>
      </article>

      <article>
        <h2>
          Относительное позиционирование
        </h2>
        <p>
          Значение
          relative
          для свойства
          position
          позволяет элементам отображаться в обычном потоке страницы, резервируя место для
          элемента как предполагалось и не позволяя другим элементам
          его обтекать. Однако, оно также позволяет модифицировать
          положение элемента с помощью свойств смещения.

          Здесь для второго элемента
          <span class="tag-inline">&lt;div&gt;</span>
          с классом
          <span class="style-inline">offset</span>
          задано значение
          <span class="style-inline">position</span> как
          <span class="style-inline">relative</span>,
          а также два свойства смещения —
          <span class="style-inline">left</span> и
          <span class="style-inline">top</span>.
          Это сохраняет исходное положение элемента и другим элементам не разрешено
          двигаться в эту область. Кроме того, свойства смещения перемещают
          элемент, выталкивая его на 20 пикселей от левого и на 20 пикселей от
          верхнего исходного местоположения.

          Для относительно позиционированных элементов важно знать, что свойства
          смещения блока определяют, куда элемент будет перемещён, учитывая его
          исходное положение. Таким образом, свойство
          <span class="style-inline">left</span>
          со значением 20 пикселей фактически толкает элемент вправо на 20 пикселей. Свойство
          <span class="style-inline">top</span>
          со значением 20 пикселей затем будет толкать элемент вниз на 20 пикселей.

          Когда мы позиционируем элемент с помощью свойств смещения, элемент
          перекрывает элемент под ним, а не сдвигает его вниз, как это делают
          свойства
          <span class="style-inline">margin</span> или
          <span class="style-inline">padding</span>.
        </p>
        <div>
          <div class="grayed" style="width: 50px; height: 50px"></div>

          <div class="grayed" style="width: 50px; height: 50px; position: relative; top:20px; left:20px">
          </div>

          <div class="grayed" style="width: 50px; height: 50px"></div>
        </div>
      </article>

      <article>
        <h2> Абсолютное позиционирование </h2>
        <p>
          Значение
          <span class="style-inline">absolute</span>
          для свойства
          <span class="style-inline">position</span>
          отличается от значения
          <span class="style-inline">relative</span>
          тем, что элемент с абсолютным позиционированием не появляется в обычном потоке документа,
          исходное пространство и положение абсолютно позиционируемого элемента не резервируется.

          Кроме того, абсолютно позиционируемые элементы перемещаются
          относительно их ближайшего относительно позиционированного
          родительского элемента. Если относительно позиционированного
          родителя не существует, то абсолютно позиционированный
          элемент будет позиционироваться относительно элемента
          <span class="tag-inline">&lt;body&gt;</span>.
        </p>

        <div style="position: relative; width: 200px">
          <div class="grayed" style="width: 50px; height: 50px"></div>

          <div class="grayed" style="width: 50px; height: 50px; position: absolute; top:10px; right:10px">
          </div>

          <div class="grayed" style="width: 50px; height: 50px"></div>
        </div>
      </article>

    </section>
  </section>
</section>


{% endblock %}
