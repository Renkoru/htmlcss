<!DOCTYPE html>

<html>
  <head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">

    <title>{{ title }}</title>
  </head>

  <body>
    <h2>DOCTYPE</h2>
    <p>
      Объявление типа документа или &lt;!DOCTYPE html&gt; находится в самом
      начале HTML-документа и сообщает браузерам, какая версия HTML применяется.
      Поскольку мы будем использовать последнюю версию HTML, наш тип
      документа будет просто &lt;!DOCTYPE html&gt;.
      После этого идёт элемент &lt;html&gt; означающий начало документа.
      Source:
      <a href="https://webref.ru/layout/learn-html-css/first-web-page">webref.ru</a>
    </p>


    <h2>&lt;head&gt;</h2>
    <p>
      Внутри &lt;html&gt; элемент &lt;head&gt; определяет верхнюю часть документа, включая разные метаданные
      (сопроводительная информация о странице). Содержимое внутри элемента &lt;head&gt; не отображается
      на самой веб-странице. Вместо этого он может включать название документа
      (который отображается в строке заголовка окна браузера), ссылки на любые внешние файлы или любые
      другие полезные метаданные.
    </p>

    <h3>meta charset</h3>
    <p>
      Задает кодировку страницы
    </p>

    <h2>&lt;body&gt;</h2>
    <p>
      Всё видимое содержимое веб-страницы будет находиться в элементе &lt;body&gt;.
    </p>

    <h2>Блочные и строчные элементы</h2>
    <p>
      Большинство элементов либо блочные, либо строчные. В чём разница?
      Блочные элементы начинаются с новой строки, накладываются друг на друга
      и занимают всю доступную ширину. Блочные элементы могут быть вложены друг в друга и
      обёртывать строчные элементы. Обычно мы видим как блочные элементы используются
      для больших кусков контента, такого как абзацы.

      Строчные элементы не начинаются с новой строки. Они попадают в обычный поток документа, выстраиваются друг за другом, а их ширина основана на их содержимом. Строчные элементы могут быть вложены друг в друга, однако, они не могут обёртывать блочные элементы. Обычно мы видим строчные элементы в качестве маленьких кусков контента, таких как отдельные слова.
    </p>

    <h2>&lt;div&gt;&lt;span&gt;</h2>
    <p>
      &lt;div&gt; является блочным элементом, который обычно используется для идентификации
      больших групп содержимого и который помогает построить макет и дизайн веб-страницы.
      &lt;span&gt; с другой стороны является строчным элементом и обычно применяется для
      идентификации мелких групп текста внутри блочного элемента.
    </p>

    <h2> &lt;h1&gt; Headers</h2>
    <p>h1 - h6.  h1 - the biggest, h6 - the smallest</p>

    <h2> &lt;p&gt; Абзацы</h2>
    <p>
      TODO: Some more info about them?
      They have margin, or padding?
    </p>

    <h2>&lt;strong&gt; &lt;b&gt; Bold text</h2>
    <p>
      Чтобы сделать текст жирным и привлечь к нему внимание мы будем использовать
      строчный элемент &lt;strong&gt;. Есть два элемента, которые выделят для нас текст
      жирным шрифтом: элементы &lt;strong&gt; и &lt;b&gt;. Важно понимать семантическую разницу между ними.

      Элемент &lt;strong&gt; семантически используется, чтобы придать сильное значение тексту и таким
      образом является наиболее популярным вариантом для жирного текста.
      Элемент &lt;b&gt;, с другой стороны, семантически означает стилистическое выделение текста,
      который не всегда является лучшим выбором для текста заслуживающего внимания.
      Мы должны оценить значимость
      текста для которого хотим установить жирность и выбрать соответствующий элемент.
    </p>

    <h2> &lt;em&gt;&lt;i&gt; Italic text</h2>
    <p>
      Для курсивного текста, на котором тем самым делается акцент, мы
      будем использовать строчный элемент &lt;em&gt;. Как и с элементами для
      жирного текста, имеются два разных элемента, которые
      устанавливают курсивный текст, каждый со своим семантическим
      смыслом.

      Элемент &lt;em&gt; применяется семантически чтобы сделать акцент на
      тексте, это наиболее популярный вариант для курсива. Другой
      вариант — это элемент &lt;i&gt;, он применяется семантически для
      передачи текста другим голосом или тоном, почти как если бы оно
      было заключено в кавычки. Опять же, нам нужно будет оценить
      значение текста, который мы хотим выделить курсивом, и выбрать
      соответствующий элемент.
    </p>

    <h2>Открытие ссылки в новом окне </h2>
    <p>
      Одной из доступных особенностей связанной
      с гиперссылками является способность определить, где ссылка откроется
      при щелчке. Как правило, ссылки открываются в том же окне, в котором
      по ним щёлкнули, однако ссылки также могут быть открыты в новых окнах.

      Для открытия ссылки в новом окне используйте атрибут target со
      значением _blank. Этот атрибут определяет, где именно будет
      отображаться ссылка, а значение _blank задаёт новое окно.

      Чтобы открыть http://shayhowe.com в новом окне, код будет выглядеть
      следующим образом:
      &lt;a href="http://shayhowe.com/" target="_blank"&gt;Шэй Хоу&lt;/a&gt;
    </p>

    <h2> Связывание частей одной страницы </h2>
    <p>
      Периодически мы увидим гиперссылки, которые указывают на часть той же
      страницы, где отображается ссылка. Типичным примером таких связей
      является ссылка «Вернуться наверх», которая возвращает пользователя к
      верхней части страницы.

      Мы можем создать ссылку на странице, сначала установив атрибут id, на
      который мы хотим ссылаться, а затем использовать его значение в
      атрибуте href элемента &lt;a&gt;.

      Используя ссылку «Вернуться наверх» в качестве примера, мы можем
      вставить атрибут id вверху для элемента &lt;body&gt;. Теперь мы можем
      создать ссылку с атрибутом href и значением #top, которая ссылается на
      начало элемента &lt;body&gt;.
    </p>

    <h1>New in html5</h1>

    <h2>&lt;nav&gt;</h2>
    <p>
      Элемент &lt;nav&gt; определяет блок основных навигационных ссылок на
      странице. Данный элемент должен быть зарезервирован только для главных
      разделов навигации, таких как глобальная навигация, оглавление,
      предыдущая/следующая ссылки или других заслуживающих внимания групп
      навигационных ссылок.

      Чаще всего ссылки внутри элемента &lt;nav&gt; будут вести на другие страницы
      в пределах одного сайта или частей той же веб-страницы. Разные
      одноразовые ссылки не должны быть обернуты элементом &lt;nav&gt;, они должны
      использовать только элемент &lt;a&gt;.
    </p>

    <h2>&lt;article&gt;</h2>
    <p>
      Элемент &lt;article&gt; применяется для идентификации
      независимого, самостоятельного раздела содержимого, который
      можно классифицировать как изолированный или повторно
      используемый. Мы часто используем элемент &lt;article&gt; для
      разметки постов блога, газетных статей, контента добавляемого
      пользователями и тому подобное.

      При принятии решения, следует ли использовать элемент
      &lt;article&gt;, мы должны определить, может ли содержимое
      элемента быть повторено в других местах без какой-либо
      путаницы. Если содержимое элемента &lt;article&gt; было удалено
      из контекста страницы и помещено, к примеру, в электронную почту
      или печатную работу, то в содержимом по прежнему должен остаться
      смысл.
    </p>

    <h2>&lt;section&gt;</h2>
    <p>
      Элемент &lt;section&gt; применяется для идентификации тематической
      группы содержимого, которая, как правило, но не всегда, включает в
      себя заголовок. Группа контента внутри &lt;section&gt; может носить
      общий характер, но полезно определить всё содержимое как связанное
      между собой.

      Элемент &lt;section&gt; обычно используется для разделения страницы и
      обеспечения на ней иерархии.
    </p>

    <h2>
      Выбор между элементами &lt;article&gt;, &lt;section&gt; или &lt;div&gt;
    </h2>
    <p>
      Порой довольно трудно решить, какой из элементов &lt;article&gt;,
      &lt;section&gt; или &lt;div&gt; лучше подходит для работы, основываясь
      на его смысловом значении. Хитростью, как и с любым семантическим
      выбором, является просмотр содержимого.

      Оба элемента &lt;article&gt; и &lt;section&gt; организуют структуру
      документа и помогают наметить его схему. Если содержимое сгруппировано
      исключительно для стилизации и не несёт ценность для схемы документа,
      используйте элемент &lt;div&gt;.

      Если содержимое добавляется к схеме документа и может быть независимо
      повторено или перенесено, используйте элемент &lt;article&gt;.

      Если содержимое добавляется к схеме документа и представляет собой
      тематическую группу содержимого, используйте элемент &lt;section&gt;.
    </p>

    <h2> &lt;aside&gt; </h2>
    <p>
      Элемент &lt;aside&gt; содержит контент, такой как боковые
      панели, вставки или краткие пояснения, который косвенно связан к
      окружающим его содержимым. К примеру, при использовании внутри
      элемента &lt;article&gt;, &lt;aside&gt; может определить
      содержимое, связанное с автором статьи.

      Мы можем инстинктивно думать об элементе &lt;aside&gt; в качестве
      элемента, который отображается слева или справа на странице. Однако мы
      должны помнить, что все структурные элементы, включая &lt;aside&gt;,
      являются блочными и как таковые выводятся с новой строки и занимают
      всю доступную ширину страницы или элемента, в который они вложены,
      также известного как их родительский элемент.
    </p>


    <h2>Example</h2>

    <div class="centered">
      <header class="grayed">&lt;header&gt;</header>
      <footer class="grayed">&lt;footer&gt;</footer>
    </div>

    <h1>CSS</h1>
    <p>
      Remember that each browser has its css pre styles. And you need to overwrite them
      if you want same styles on all browsers. (it is named as "Reset CSS")
    </p>

    <h2> Вычисление специфичности </h2>
    <p>
      Каждый селектор в CSS имеет вес специфичности, он вместе с положением
      в каскаде определяет, как будут отображаться стили.

      В уроке 1 «Создание первой веб-страницы» мы говорили о трёх разных
      видах селекторов: селектор типа, класс и идентификатор. Каждый из этих
      селекторов имеет различный вес специфичности.

      У селектора типа низкий вес специфичности и значение балла 0-0-1. У
      селектора класса средний вес специфичности и значение балла
      0-1-0. Наконец, у идентификаторов высокая специфичность и значение
      балла 1-0-0. Как мы видим, баллы специфичности вычисляются с помощью
      трёх колонок. В первой колонке количество идентификаторов, во второй
      классов, а третья колонка считает селекторы типа.

      Важно отметить, что идентификатор имеет больший вес специфичности чем
      селектор класса, а класс больший вес, чем селектор типа.
    </p>
    <p>
      TODO it like a table <br>
      .hotdog p         - 0-1-1 <br>
      .hotdog p.mustard - 0-2-1 <br>
      .hotdog .mustard  - 0-2-0 <br>
    </p>

    <h2>Sizes</h2>
    <p>Pixels</p>
    <p>% of parent size</p>
    <p>
      1em = font-size <br/>
      em часто применяется для стилизации текста, в том числе размера
      шрифта, а также пространства вокруг текста, включая margin и
      padding.
    </p>

    <h2>CSS. display</h2>
    <p>
      Есть немало значений для свойства display, но наиболее
      распространённые это block, inline, inline-block и none.  Мы
      можем изменить значение свойства display элемента, выбрав этот
      элемент в CSS и задав новое значение свойства display. Значение
      block сделает этот элемент блочным.  Значение inline сделает
      этот элемент строчным.  Самое интересное это значение
      inline-block. Его использование позволит элементу вести себя как
      блочный, включая все свойства блочной модели (которые мы вскоре
      рассмотрим). Однако, элемент будет отображаться на строке с
      другими элементами, а не будет начинаться с новой строки по
      умолчанию.
      В заключение, используя значение none полностью скрываем элемент и
      отображаем страницу, словно элемента не существует. Любые элементы,
      вложенные в такой элемент, также будут скрыты.
    </p>

    <h2> Что такое блочная модель? </h2>
    <p>
      В соответствии с концепцией блочной модели,
      каждый элемент на странице представляет собой прямоугольный блок и
      может иметь ширину, высоту, поля, границы и отступы.

      Это стоит повторить: Каждый элемент на странице представляет собой
      прямоугольный блок.
      Каждая часть блочной модели соответствует свойству CSS: width, height,
      padding, border и margin.
    </p>
    <p>
      В соответствии с блочной моделью общая ширина элемента может
      быть рассчитана по следующей формуле:

      margin-right + border-right + padding-right + width + padding-left + border-left + margin
    </p>
    <img alt="Box-Model" src="static/box-model.png">

    <h2>CSS. width</h2>
    <p>
      По умолчанию ширина элемента основана на значении display. У блочных
      элементов ширина по умолчанию 100% и занимает всё доступное
      горизонтальное пространство. Строчные и строчно-блочные элементы
      расширяются и сжимаются горизонтально для размещения их
      содержимого. Строчные элементы не могут иметь фиксированный размер,
      таким образом, ширина и высота относятся только к не строчным
      элементам. Чтобы задать определённую ширину для не строчных элементов,
      используйте свойство width.
    </p>

    <h5>inline elem: <em>(css width does not work)</em></h5>
    <span class="width400px grayed">width = 400px</span>

    <h5>block elem:</h5>
    <div class="width400px grayed">width = 400px</div>

    <h2> Размеры строчно-блочных элементов </h2>
    <p>
      Пожалуйста, помните, что строчные элементы не принимают свойства width
      и height и любые их значения. Блочные и строчно-блочные элементы,
      однако, принимают свойства width и height и соответствующие им
      значения.
    </p>

    <h2>margin</h2>
    <p>
      Свойство margin позволяет нам установить пространство, которое
      окружает элемент. margin находятся за пределами любых границ и
      полностью прозрачны в цвете. Они могут использоваться для
      позиционирования элементов в конкретном месте на странице или добавить
      пустое пространство, сохраняя все другие элементы на безопасном
      расстоянии. Вот свойство margin в действии:

      Одной из причуд margin являются вертикальные значения, сверху и снизу,
      они не применяются к строчным элементам, но применяются к блочным и
      строчно-блочным элементам.
    </p>

    <h5>inline elem: <em>(vertical margin does not work)</em></h5>
    <div class="bordered-wrapper">
      <span class="margined10px grayed">margin: 10px</span>
    </div>

    <h5>block elem:</h5>
    <div class="bordered-wrapper">
      <div class="margined10px grayed">margin: 10px</div>
    </div>

    <h2> margin и padding для строчных элементов </h2>
    <p>
      Строчные элементы ведут себя немного по-другому, чем блочные и
      строчно-блочные элементы, когда дело доходит до отступов и полей. Для
      строчных элементов margin работает только горизонтально — слева и
      справа от элементов. padding работает на всех четырёх сторонах
      строчных элементов, однако вертикальные поля сверху и снизу могут
      выходить за пределы строки выше и ниже элемента.

      Отступы и поля работают как обычно для блочных и строчно-блочных
      элементов.
    </p>

    <h2> Цвет отступов и полей </h2>
    <p>
      Свойства margin и padding полностью прозрачны и не принимают
      какие-либо цветовые значения. Но будучи прозрачными они
      показывают цвет фона связанных элементов. Для margin мы видим
      цвет фона родительского элемента, а для padding видим цвет фона
      элемента, к которому применяется padding.
    </p>

    <h2> Границы для отдельных сторон </h2>
    <p>
      Как и со свойствами margin и padding границы могут быть размещены на
      одной стороне элемента за раз при желании. Это требует новых свойств:
      border-top, border-right, border-bottom и border-left. Значения для
      этих свойств такие же, как и для border: ширина, стиль и цвет. При
      желании можно сделать так, чтобы граница появлялась только внизу
      элемента:

      div { border-bottom: 6px solid #949599; } Кроме того, стилями для
      отдельных сторон можно управлять на ещё более тонком
      уровне. Например, если мы хотим изменить только ширину нижней
      границы, то можем использовать следующий код:

      div { border-bottom-width: 12px; } Такое довольно специфичное свойство
      границы включают в себя ряд разделённых дефисом слов, начинающихся с
      border, затем идёт выбранная сторона — top, right, bottom или left,
      а затем width, style или color, в зависимости от желаемого свойства.
    </p>

    <h2> Размеры блока </h2>
    <p>
      До сих пор блочная модель была аддитивной. Если вы установили для
      width 400 пикселей, затем добавили 20 пикселей padding и border 10
      пикселей на каждой стороне, фактическая полная ширина элемента
      становится 460 пикселей. Помните, мы должны сложить значения свойств
      width, padding и border вместе, чтобы получить реальную полную ширину
      элемента.

      Блочная модель, однако, может быть изменена, чтобы вычисления
      происходили иначе. <strong>CSS3</strong> ввёл свойство box-sizing, которое позволяет
      нам точно менять, как блочная модель работает и как вычисляются
      размеры элемента. Это свойство принимает три основных значения —
      content-box, padding-box и border-box, каждое из которых оказывает
      несколько разное влияние на вычисление размера блока.
    </p>

    <h2> Свойства и значения специфичные для браузера </h2>
    <p>
      Что означают все эти дефисы и буквы в свойстве box-sizing?

      Когда был представлен CSS3, браузеры постепенно начали
      поддерживать разные свойства и значения, включая свойство
      box-sizing, путём добавления вендорных префиксов. Когда части
      спецификации CSS3 будут завершены и выпущены новые версии
      браузеров, эти префиксы станут всё менее и менее актуальными. Со
      временем префиксы вряд ли будут проблемой, однако, они всё ещё
      обеспечивают поддержку некоторых старых браузеров. Мы можем
      работать с ними время от времени и, возможно, даже захотим
      использовать их, если нам нужна поддержка старых браузеров.

      Вендорные префиксы можно увидеть для свойств и значений, всё
      зависит от спецификации CSS. Здесь они показаны для свойства
      box-sizing. Разработчики браузеров были свободны в выборе, когда
      использовать префикс, а когда нет. Таким образом, одни свойства
      и значения требуют префиксы для некоторых браузеров, а другие
      нет.

      Ниже, когда свойство или значение требует вендорный префикс, то
      префикс будет использоваться только для представления этого
      свойства или значения (в интересах сохранения нашего кода
      простым и кратким). Не забудьте добавить необходимые префиксы,
      когда вы станете писать реальный код.

      Для справки, наиболее распространённые префиксы изложены здесь:

      Mozilla Firefox: -moz- Microsoft Internet Explorer: -ms- Webkit
      (Google Chrome и Apple Safari): -webkit-
    </p>

    <h3> content-box </h3>
    <p>
      Значение content-box является значением по умолчанию, оставляя
      блочную модель в качестве аддитивной. Если мы не используем
      свойство box-sizing, то это будет значением по умолчанию для
      всех элементов. Размер элемента начинается со свойств width и
      height, далее к ним добавляются значения свойств padding, border
      или margin .
    </p>

    <h3>padding-box</h3>
    <p>
      Значение padding-box изменяет блочную модель путём включения
      всех значений свойства padding внутри width и height
      элемента. При использовании значения padding-box, если у элемент
      width равно 400 пикселей и padding 20 пикселей вокруг всех
      сторон, фактическая ширина останется 400 пикселей. При
      увеличении padding на любое значение, размер содержимого внутри
      элемента сжимается пропорционально.

      Если мы добавим border или margin, эти значения будут добавлены
      к свойствам width или height для вычисления полного размера
      блока. Например, если мы добавим border 10 пикселей и padding 20
      пикселей вокруг всех сторон элемента, у которого width 400
      пикселей, фактическая полная ширина будет 420 пикселей.
    </p>
    <img alt="" src="static/box-sizing.png">

    <h2> Выбор размера блока </h2>
    <p>
      Вообще говоря, лучшее значение box-sizing для применения — это
      border-box. Это значение намного упрощает нам математику. Если мы
      хотим, чтобы весь элемент был 400 пикселей в ширину, он останется 400
      пикселей в ширину, независимо от того, какие значения padding или
      border мы к нему добавляем.

      Кроме того, мы можем легко смешивать значения длины. Скажем, мы хотим,
      чтобы наш блок занимал 40% в ширину. Добавление padding 20 пикселей и
      border 10 пикселей для всех сторон элемента не сложно и мы по-прежнему
      можем гарантировать, что фактическая ширина нашего блока останется
      40%, несмотря на использование пикселей в другом месте.

      Единственный недостаток свойства box-sizing в том, что как часть
      спецификации CSS3 она не поддерживается во всех браузерах, особенно не
      хватает поддержки в старых версиях. К счастью, это становится всё
      менее и менее актуальным, поскольку выходят новые версии. Скорее
      всего, мы можем безопасно использовать свойство box-sizing, но если вы
      заметили какие-то проблемы, стоит посмотреть с каким браузером они
      связаны.
    </p>

    <h2> Универсальный селектор </h2>
    <p>
      На первом этапе данного упражнения мы представили универсальный
      селектор. В CSS звёздочка (*) это универсальный селектор,
      который выбирает каждый элемент. Вместо перечисления всех
      отдельных элементов мы можем использовать звёздочку для выбора
      всех элементов.

      Псевдоэлементы :before и :after также упомянутые на этом этапе — это
      элементы, которые могут динамически генерироваться через CSS. Мы не
      станем применять эти элементы в нашем проекте, однако, при упоминании
      универсального селектора также хорошим тоном будет включить эти
      псевдоэлементы на случай, если они когда-нибудь появятся.
    </p>



    <h1>Позиционирование содержимого</h1>


  </body>

</html>
